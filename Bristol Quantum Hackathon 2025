# --- Imports
%pip install --upgrade pip
%pip install networkx qiskit qiskit-aer qiskit-optimization matplotlib cirq
import networkx as nx
import numpy as np
import itertools
import matplotlib.pyplot as plt

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import QAOAAnsatz
from qiskit_aer import AerSimulator
from qiskit import transpile
from qiskit.visualization import plot_histogram

# --- 1) Build the weighted graph
G = nx.Graph()
G.add_edge(0, 1, weight=2)
G.add_edge(1, 2, weight=500)
G.add_edge(2, 3, weight=1)
G.add_edge(3, 0, weight=5)
G.add_edge(3, 4, weight=10000)
G.add_edge(4, 1, weight=3)
# (keep any extra edges commented if you wish)

n = G.number_of_nodes()
nodes = list(G.nodes)

# --- 2) Build the QAOA cost operator H = sum_ij w_ij * (I - Z_i Z_j)/2
# Qiskit uses little-endian Pauli strings (qubit 0 is right-most char).
def zz_op(i, j, n_qubits):
    s = ['I'] * n_qubits
    s[n_qubits - 1 - i] = 'Z'
    s[n_qubits - 1 - j] = 'Z'
    return SparsePauliOp(''.join(s), [1.0])

I = SparsePauliOp.from_list([('I' * n, 1.0)])

cost_op = None
const_offset = 0.0
for u, v, data in G.edges(data=True):
    w = float(data.get('weight', 1.0))
    term = (I - zz_op(u, v, n)) * (w * 0.5)
    cost_op = term if cost_op is None else (cost_op + term)
    const_offset += 0.0  # offset is embedded via the I term above; kept for clarity

# --- 3) QAOA circuit (you can change reps)
reps = 2
ansatz = QAOAAnsatz(cost_operator=cost_op, reps=reps)
ansatz.measure_all()

# Random parameters for a quick demo (use an optimizer for real runs)
params = dict(zip(ansatz.parameters,
                  np.concatenate([
                      np.random.uniform(0, np.pi, reps),      # betas
                      np.random.uniform(0, 2*np.pi, reps)     # gammas
                  ])))
qc = ansatz.assign_parameters(params)

# --- 4) Simulate
sim = AerSimulator()
compiled = transpile(qc, sim)
result = sim.run(compiled, shots=10_000).result()
counts = result.get_counts()

print("Weighted Max-Cut measurement counts (top 10):")
print(dict(sorted(counts.items(), key=lambda x: x[1], reverse=True)[:10]))

# --- 5) Filter trivial all-0 / all-1 bitstrings (optional)
def is_trivial(bitstr):
    return bitstr.count('0') in (0, len(bitstr))  # all 1s or all 0s
filtered_counts = {s: c for s, c in counts.items() if not is_trivial(s)}
print("\nFiltered non-trivial results (top 10):")
print(dict(sorted(filtered_counts.items(), key=lambda x: x[1], reverse=True)[:10]))

# --- 6) Classical weighted Max-Cut (brute force for small n)
def weighted_cut_value(G, subset):
    """Sum of weights for edges crossing between subset and its complement."""
    S = set(subset)
    value = 0.0
    for u, v, data in G.edges(data=True):
        if (u in S) ^ (v in S):  # XOR: exactly one in S
            value += float(data.get('weight', 1.0))
    return value

def classical_maxcut(G):
    best_val = -1.0
    best_part = None
    V = list(G.nodes)
    # skip empty and full subsets to avoid trivial partitions
    for r in range(1, len(V)):
        for subset in itertools.combinations(V, r):
            # to avoid double-counting complementary partitions, enforce smallest node in subset
            if 0 in V and (0 not in subset):  # simple symmetry breaker using node 0
                continue
            val = weighted_cut_value(G, subset)
            if val > best_val:
                best_val = val
                best_part = (set(subset), set(V) - set(subset))
    return best_val, best_part

best_val, best_partition = classical_maxcut(G)
print(f"\nClassical weighted Max-Cut value: {best_val}")
print(f"Best partition: {sorted(list(best_partition[0]))} | {sorted(list(best_partition[1]))}")

# --- 7) Plot histogram
fig = plot_histogram(counts)
plt.show()
